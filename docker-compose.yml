###
### BEFORE RUNNING

# DEV SETTINGS:
### nuxt.config.js
#       baseURL: 'http://127.0.0.1:5000',
#       https: false,


# PROD SETTINGS:
### nuxt.config.js
#       baseURL: #'http://api.tax-automation.com' # at the moment false, later --> #'https://api.tax-automation.com',
#       https: false # at the moment false, later --> #true,



version: '3'

services:

    front:
        container_name: front
        build:
            context: ./front
            dockerfile: Dockerfile
            args:
                - NODE_VERSION=${NODE_VERSION}
        image: ${OWNER_NAME}/front:${VERSION_NUMBER}
        restart: always
        expose: # EXPOSE only opens up a port within a docker network, while PORTS allows access from the outside world (the internet)
            - "3000"
        depends_on:
            - api
        networks:
            - web
        command: "npm run start"




    # ## new
    # rabbitmq:
    #     image: rabbitmq:3-alpine
    #     expose:
    #         - "15672"
    #         - "5672"
    #     environment:
    #         RABBITMQ_ERLANG_COOKIE: ${RABBITMQ_ERLANG_COOKIE}
    #         RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER}
    #         RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}
    #         RABBITMQ_NODE_PORT: ${RABBITMQ_NODE_PORT}
    #     healthcheck:
    #         test: ['CMD', 'rabbitmqctl', 'status']
    #         interval: 30s
    #         timeout: 15s
    #         retries: 3

    # redis:
    #     image: redis:5-alpine
    #     expose:
    #         - "6379"
    #     healthcheck:
    #         test: ['CMD', 'redis-cli', 'ping']
    #         interval: 30s
    #         timeout: 15s
    #         retries: 3

    # celery-worker:
    # # build:
    # #   context: .
    # #   dockerfile: docker/app/Dockerfile
    # image: celery:latest
    # command: ['app-celery-worker']
    # environment:
    #     CELERY_BROKER_URL: ${CELERY_BROKER_URL}
    #     CELERY_RESULT_BACKEND: ${CELERY_RESULT_BACKEND}
    #     CACHE_REDIS_URL: ${CACHE_REDIS_URL}
    #     SESSION_TYPE: ${SESSION_TYPE}
    #     SESSION_REDIS_URL: ${SESSION_REDIS_URL}
    # depends_on:
    #     - rabbitmq
    #     - redis

    # ##^#new

    # migration:
    #     container_name: migration
    #     build:
    #         context: ./api
    #         dockerfile: Dockerfile
    #         args:
    #             - PYTHON_VERSION=${PYTHON_VERSION}

    #     image: ${OWNER_NAME}/migration:${VERSION_NUMBER}
    #     environment:
    #         - FLASK_ENV=${FLASK_ENV}
    #     command: flask db upgrade
    #     depends_on:
    #         - postgres
    #     networks:
    #         - internal

    api:
        container_name: api
        build:
            context: ./api
            dockerfile: Dockerfile
            args:
                - PYTHON_VERSION=${PYTHON_VERSION}
        image: ${OWNER_NAME}/api:${VERSION_NUMBER}
        restart: always
        expose:
            - "5000"
        depends_on: # depends_on defines the order in which the services are started
            - postgres
            # - rabbitmq #new
            # - redis #new
            # - celery-worker #new
        volumes:
            - logs:/logs
            - seeds:/seeds
            - templates:/templates
            - seller_firm_data:/seller_firm_data
        networks:
            - internal
            - web
        command: bash -c "./wait-for-it.sh postgres:5432 --timeout=2 && gunicorn --bind 0.0.0.0:5000 wsgi:app"


    postgres:
        container_name: postgres
        build:
            context: ./db
            dockerfile: Dockerfile
            args:
                - POSTGRES_VERSION=${POSTGRES_VERSION}
        image: ${OWNER_NAME}/postgres:${VERSION_NUMBER}
        restart: always
        environment:
            - DATABASE=postgres
        expose:
            - "5432"
        volumes:
            - pgdata:/pgdata
        networks:
            - internal

networks:
    internal:
    web:


volumes:
    pgdata:
    logs:
    seeds:
    templates:
    seller_firm_data:
