###
### BEFORE RUNNING

# DEV SETTINGS:
### nuxt.config.js
#       baseURL: 'http://127.0.0.1:5000',
#       https: false,


# PROD SETTINGS:
### nuxt.config.js
#       baseURL: #'http://api.tax-automation.com' # at the moment false, later --> #'https://api.tax-automation.com',
#       https: false # at the moment false, later --> #true,



version: '3'

services:


    proxy:
        container_name: proxy
        # The official v2 Traefik docker image
        image: traefik:v2.3
        # Enables the web UI and tells Traefik to listen to docker
        ports:
            # The HTTP port
            - "80:80"
         # The Web UI (enabled by --api.insecure=true)
            - "8080:8080"
        volumes:
            # So that Traefik can listen to the Docker events
            - /var/run/docker.sock:/var/run/docker.sock
        restart: unless-stopped
        # networks:
        #     - web
        # depends_on:
        #     - api
        command: --api.insecure=true --providers.docker

    whoami:
        # A container that exposes an API to show its IP address
        image: traefik/whoami
        labels:
        - "traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)"

    # proxy:
    #     container_name: proxy
    #     build:
    #         context: ./nginx
    #         dockerfile: Dockerfile
    #         args:
    #             - NGINX_VERSION=${NGINX_VERSION}
    #             - ENVIRONMENT=dev
    #     image: ${OWNER_NAME}/proxy:${VERSION_NUMBER}
    #     restart: unless-stopped
    #     # volumes:
    #     #       - media_data:/var/lib/media_data:ro
    #     ports:
    #         - 5000:5000
    #         # - 22406:22406
    #         # - 31729:31729
    #         - 80:80
    #     networks:
    #         - web
    #     depends_on:
    #         - api

    #     command: '/bin/sh -c ''while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g "daemon off;"'''
    #     # improved version based on: https://stackoverflow.com/questions/57554703/why-use-nginx-with-daemon-off-in-background-with-docker
    #     #command: '/bin/sh -c ''while :; do sleep 6h; nginx -s reload; done & exec nginx -g "daemon off;"'''


    front:
        container_name: front
        build:
            context: ./front
            dockerfile: Dockerfile
            args:
                - NODE_VERSION=${NODE_VERSION}
        image: ${OWNER_NAME}/front:${VERSION_NUMBER}
        restart: always
        expose: # EXPOSE only opens up a port within a docker network, while PORTS allows access from the outside world (the internet)
            - "14000"
        # depends_on:
        #     - api
        networks:
            - web
        command: "npm run start"


    # front_tax:
    #     container_name: front_tax
    #     build:
    #         context: ./front_tax
    #         dockerfile: Dockerfile
    #         args:
    #             - NODE_VERSION=${NODE_VERSION}
    #     image: ${OWNER_NAME}/front_tax:${VERSION_NUMBER}
    #     restart: always
    #     expose: # EXPOSE only opens up a port within a docker network, while PORTS allows access from the outside world (the internet)
    #         - "22406"
    #     # depends_on:
    #     #     - api
    #     networks:
    #         - web
    #     command: "npm run start"


    # front_admin:
    #     container_name: front_admin
    #     build:
    #         context: ./front_admin
    #         dockerfile: Dockerfile
    #         args:
    #             - NODE_VERSION=${NODE_VERSION}
    #     image: ${OWNER_NAME}/front_admin:${VERSION_NUMBER}
    #     restart: always
    #     expose: # EXPOSE only opens up a port within a docker network, while PORTS allows access from the outside world (the internet)
    #         - "31729"
    #     # depends_on:
    #     #     - api
    #     networks:
    #         - web
    #     command: "npm run start"



    rabbitmq:
        container_name: rabbitmq
        image: rabbitmq:management #3-alpine

        ports:
            - "15672:15672"
            - "5672:5672"
        healthcheck:
            test: ['CMD', 'rabbitmqctl', 'status']
            interval: 30s
            timeout: 15s
            retries: 3
        networks:
            - internal
            - web

    redis:
        container_name: redis
        build:
            context: ./redis
            dockerfile: Dockerfile
            args:
                - REDIS_VERSION=${REDIS_VERSION}
        ports:
            - "6379:6379"
        depends_on:
            - helper
        healthcheck:
            test: ['CMD', 'redis-cli', 'ping']
            interval: 30s
            timeout: 15s
            retries: 3
        networks:
            - web
            - internal
        sysctls:
            - net.core.somaxconn=511

    helper:
        container_name: helper
        image: alpine
        command: sh -c "echo never > /sys/kernel/mm/transparent_hugepage/enabled"
        privileged: true


    celery-worker:
        # container_name: celery-worker
        build:
            context: ./api
            dockerfile: Dockerfile
            args:
                - PYTHON_VERSION=${PYTHON_VERSION}
                # - GROUP_ID=1237
                # - USER_ID=10239

        volumes:
            - data:/home/data

        depends_on:
            - postgres
            - rabbitmq
            - redis
        networks:
            - internal

        #The -A option gives Celery the application module and the Celery instance
        # https://stackoverflow.com/questions/59651428/runtimewarningyoure-running-the-worker-with-superuser-privilegesthis-is-absol
        # Celery 4 has nasty, very hard to find bug in worker.
        # It works only with 4 defined queues after -Q parameter. If you need more queues, just start more workers.
        # reference: https://pawelzny.com/python/celery/2017/08/14/celery-4-tasks-best-practices/
        command: bash -c "celery -A wsgi:celery worker -P gevent --loglevel=info" #-Q default,low_priority,high_priority" !!!

        # The number of worker processes/threads can be changed using the --concurrency argument and defaults to the number of CPUs available on the machine.

    celery-beat:
        container_name: celery-beat
        build:
            context: ./api
            dockerfile: Dockerfile
            args:
                - PYTHON_VERSION=${PYTHON_VERSION}
                # - GROUP_ID=${GROUP_ID}
                # - USER_ID=${USER_ID}

        depends_on:
            - postgres
            - rabbitmq
            - redis
            - celery-worker
        networks:
            - internal
                                    #The -A option gives Celery the application module and the Celery instance
        command: bash -c "celery -A wsgi:celery beat --loglevel=info"



    # flower:
    #     # https://www.distributedpython.com/2018/10/13/flower-docker/
    #     container_name: flower
    #     image: mher/flower
    #     expose:
    #         - "8888"
    #     # ports:
    #     #     - 8888:8888
    #     depends_on:
    #         - celery-worker
    #         # - celery-beat
    #     networks:
    #         - internal


    api:
        container_name: api
        build:
            context: ./api
            dockerfile: Dockerfile
            args:
                - PYTHON_VERSION=${PYTHON_VERSION}
                # - GROUP_ID=${GROUP_ID}
                # - USER_ID=${USER_ID}
        image: ${OWNER_NAME}/api:${VERSION_NUMBER}
        restart: always
        expose:
            - "5000"
        # ports:
        #     - 5000:5000
        depends_on: # depends_on defines the order in which the services are started
            - postgres
            - rabbitmq #new
            - redis #new
            - celery-worker #new
        volumes:
            - logs:/home/logs
            - seeds:/home/seeds
            - templates:/home/templates
            - data:/home/data
        networks:
            - internal
            - web
        command: bash -c "./wait-for-it.sh postgres:5432 --timeout=2 && gunicorn wsgi:app --bind dev.loc:5000 --timeout 180 --worker-class geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 --worker-connections 1000 --log-level=debug" #gunicorn --bind 0.0.0.0:5000 wsgi:app"


    postgres:
        container_name: postgres
        build:
            context: ./db
            dockerfile: Dockerfile
            args:
                - POSTGRES_VERSION=${POSTGRES_VERSION}
        image: ${OWNER_NAME}/postgres:${VERSION_NUMBER}
        restart: always
        volumes:
            - data:/data
        environment:
            - DATABASE=postgres
        expose:
            - "5432"
        networks:
            - internal

networks:
    internal:
    web:


volumes:
    logs:
    seeds:
    templates:
    data:
